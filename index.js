// "[" <sound-id> "]" "(" <sprite-name> ")" <whitespace> <participant-name> ":" <whitespace> <text> <end-of-line>
const LINE_REGEX = /^\s*{\s*([0-9.]+)\s*}\s*\[\s*(\d+)\s*\]\s*\(\s*([a-zA-Z1-9_]+)\s*\)\s*([a-zA-Z0-9_\s]+):\s(.+)$/;
// tis a command dawg, aint theoretical physics
const COMMENT_REGEX = /^\s*(#|--|;;|\/\/).*$/;
// <sprite-name> "=" <number>
const SPRITE_REGEX = /^\s*([a-zA-Z0-9_]+)\s*=\s*(\d+)\s*$/;
// <config-key> "=" <number>
const CONFIG_REGEX = /^\s*\$\s*([a-zA-Z0-9_]+)\s*=\s*(\d+)\s*$/;

var ERROR_MESSAGE = "";

function remove_junk(lines) {
    var result = [];
    lines.forEach(line => {
        if(line.match(COMMENT_REGEX) == null) {
            result.push(line);
        }
    });
    return result;
}

function parse(lines) {
    var result = {
        configs: {
            autonext: 0,
        },
        participantA: {
            name: null,
            sprites: {}
        },
        participantB: {
            name: null,
            sprites: {}
        },
        conversationLines: [],
    };

    var participantID = "A";
    var name_has_been_found = false;
    var got_participants = false;
    var error = false;
    var config_parsed = false;
    lines.forEach((line, index) => {
        if(error) return;
        if(!config_parsed){
            if(line.trim().length == 0) {
                config_parsed = true;
                return;
            }
            else if((found = line.match(CONFIG_REGEX)) != null){
                result.configs[found[1]] = parseInt(found[2]);
                return;
            } else {
                config_parsed = true;
                /*
                ERROR_MESSAGE = `error while parsing config keys:\nline ${index}: not a blank line or a config line!\ncorrect:< $config_key = config_value >\n\n${index}:< ${line} >`;
                alert(ERROR_MESSAGE);
                error = true;
                */
            }
        } if(got_participants){
            if(line.trim().length == 0) return;
            else if((found = line.match(LINE_REGEX)) != null){
                var object = {
                    text: found[5],
                    sprite: found[3],
                    voice: found[2],
                    delay: found[1]
                };
                switch (found[4]) {
                    case result.participantA.name: object.subject = "participantA"; break;
                    case result.participantB.name: object.subject = "participantB"; break;
                    default:
                        ERROR_MESSAGE = `error while parsing dialogue:\nline ${index}: participant "${found[4]}" has not been defined!\ncorrect: "${result.participantA.name}" or "${result.participantB.name}"!\n\n${index}:< ${line} >`;
                        alert(ERROR_MESSAGE);
                        error = true;
                        return;
                }
                result.conversationLines.push(object);
            } else {
                ERROR_MESSAGE = `error while parsing dialogue:\nline ${index}: not a blank line or a dialogue line!\ncorrect:< {Delay}[Sound_id](Sprite_name) Participant Name: Things I will say. >\n\n${index}:< ${line} >`;
                alert(ERROR_MESSAGE);
                error = true;
                return;
            }
        }
        else if(!name_has_been_found){
            result["participant" + participantID].name = line.trim();
            name_has_been_found = true;
            return;
        } else {
            var found = line.match(SPRITE_REGEX);
            if(found != null) {
                result["participant" + participantID].sprites[found[1]] = found [2];
                return;
            } else if (line.trim().length == 0) {
                if(participantID == "B") {
                    got_participants = true;
                    return;
                }
                participantID = "B";
                name_has_been_found = false;
                return;
            } else {
                ERROR_MESSAGE = `error while parsing participants:\nline ${index}: not a blank line or a sprite definition!\ncorrect:< Sprite_name = 1234567890 >\n\n${index}:< ${line} >`;
                alert(ERROR_MESSAGE);
                error = true;
                return;
            }
        }
    });

    return (error) ? null : result;
}

function produce_lua(input) {
    var result = `-- autogenerated by BCT at ${new Date().toLocaleDateString()} ${new Date().toLocaleTimeString()}\nlocal c={`;

    result += `participantA={name="${input.participantA.name.trim()}",sprites={`;
    for (let [key, value] of Object.entries(input.participantA.sprites)) {
        result += `${key}=${value},`;
    }
    result += `}},participantB={name="${input.participantB.name.trim()}",sprites={`;
    for (let [key, value] of Object.entries(input.participantB.sprites)) {
        result += `${key}=${value},`;
    }
    result += "}},conversation={";
    input.conversationLines.forEach((line) => {
        result += `{subject="${line.subject}",text="${line.text}",sprite="${line.sprite}",voice=${line.voice},delay=${line.delay}},`;
    });

    result += "},";

    for (let [key, value] of Object.entries(input.configs)) {
        result += `${key}=${value},`;
    }

    result += "}\nreturn c";

    return result;
}

function produce_pretty_lua(input) {
    var result = `-- autogenerated by BCT at ${new Date().toLocaleDateString()} ${new Date().toLocaleTimeString()}\nlocal c = {\n`;

    result += `    participantA = {\n        name = "${input.participantA.name.trim()}",\n        sprites = {\n`;
    for (let [key, value] of Object.entries(input.participantA.sprites)) {
        result += `            ${key} = ${value},\n`;
    }
    result += `        }\n    },\n    participantB = {\n        name = "${input.participantB.name.trim()}",\n        sprites = {\n`;
    for (let [key, value] of Object.entries(input.participantB.sprites)) {
        result += `            ${key} = ${value},\n`;
    }
    result += "        }\n    },\n    conversation = {\n";
    input.conversationLines.forEach((line) => {
        result += `        {\n            subject = "${line.subject}",\n            text = "${line.text}",\n            sprite = "${line.sprite}",\n            voice = ${line.voice},\n            delay = ${line.delay}\n        },\n`;
    });

    result += "    },\n"; 

    for (let [key, value] of Object.entries(input.configs)) {
        result += `    ${key} = ${value},\n`;
    }

    result += "\n}\nreturn c";

    return result;
}

function transpile(input, pretty) {
    input = input.split('\n');
    input = remove_junk(input);
    input = parse(input);
    if(input==null) {
        document.getElementById('output_area').value = `-- an error has occurred, please fix as told by the message box and try again!\n--[[\n${ERROR_MESSAGE}\n]]`;
        console.log(input);
        return;
    }
    document.getElementById('output_area').value = (pretty) ? produce_pretty_lua(input): produce_lua(input);
    return;
}